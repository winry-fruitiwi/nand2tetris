IMPORTANT: Important items often are CAPS-LOCKed, and I will put a tag in all caps "caps-lock" to search.
HA means Hack Assembly.
I'm using "you" to address myself.





April 11th, 2022

Unit 1.0
road map: Jack→Compiler→VM→Translator→assembly→assembler→computer



Unit 1.1

preview of end:
	review of jack
	get to high-level programs
	write once, run anywhere! as opposed to write once, fix everywhere
	java VM: bytecode, give computers JVM implementation
	vm translator!
	translating from one language to an assembly script is a headache
	use intermediate steps: one compiler, a couple translators, a couple assemblers
	idea is almost 90 years old!

preview of jack:
	java similarity
	one platform, PC, other Hack
	write compiler, put in Jack code, write translator, put in VM code

virtual machine:
	virtualization
	not real
	alan turing is very happy!
	reason about reasoning
	turing: "we can only see a short distance ahead, but we can see plenty there that needs to be done"

take home lessons:
	compilation
	virtualization
	VM abstraction
	stack processing
	VM implementation
	pointers
	programming



Unit 1.2

two conflicting objectives: height, lowness
jump should not be very high

optimal jump: stack machine abstraction
	architecture (stack):
		operations are push and pop
		stack is similar to ram (memory)
		memory = array, stack = stack
		push memory: add to stack
		pop memory: remove from stack, add to memory
	arithmetic commands:
		add: pop two topmost values, add on side, push result
		neg: pop top value, negate side, push back on
		function: pop arguments, compute f, push result (part of abstraction)
		eq: pop two top values, check if equal, push result back on
		or: pop two top values, evaluate boolean or, push result on



Unit 1.2, second and third session

two conflicting objectives: height, lowness
jump should not be very high

optimal jump: stack
	architecture (stack):
		operations are push and pop
		stack is similar to ram (memory)
		memory = array, stack = stack
		push memory: add to stack
		pop memory: remove from stack, add to memory
	
	arithmetic commands:
		add: pop two topmost values, add on side, push result
		neg: pop top value, negate side, push back on
		function: pop arguments, compute f, push result (part of abstraction)
		eq: pop two top values, check if equal, push result back on
		or: pop two top values, evaluate boolean or, push result on
	
	where did these commands come from?
		the compiler!
		start from x = 17 + 19
		compile: push 17; push 19; add; pop x
		the high-level language is an abstraction
		it can be implemented by a stack machine
		the stack machine is an abstraction
		it can be implemented by something unknown
	
	VM code is a stack machine manipulated by:
		arithmetic / logical commands → example
		memory segment commands
		branching commands
		function commands

	arithmetic/logical commands are:
		add			x + y
		sub			x - y
		neg			-y
		eq			x == 0 (error? this should be x==y)
		gt			x > y
		lt			x < y
		and			x and y
		or 			x or y
		not			not y

	observation:
		any expression that is arithmetic or logical can be evaluated with this stack.
		You can do anything with VM codes. Tigress out.



Unit 1.3, number of sessions: 2

let c = s1 + y; → compiler → push s1; push y; add; pop c
how did compiler do this?





April 13th

Unit 1.3, number of sessions today: 1

[0250]-	cannot preserve variable names or else execution will be wrong
introducing: virtual memory segments!

instead of saying `push s1` we say `push ${s1Value}` but we lose variable names

jvm does not interpret symbolic variable names.

memory segment: constant! just 0-1-2-3-4-5-...

why do we always have to say ... segment ...?
	because it needs to be consistent and easy to compile

actually there are eight memory segments, not four! why though?
	we come from object oriented programs
	there are a lot of variables and nuances there
	for example, we always reference a lot of numbers

there is one thing that eight memory segments versus one does not affect:
	all push statements are the same!

[0258]-	quiz

imprint a value: quiz
solution:
	push imprint
	pop imprinted
THE only way is this!

finished talking about:
	arithmetic/logical commands (pseudo-quiz up ahead for me!)
	memory segment commands (push segment i, pop nonConstantSegment i)

arithmetic/logical commands:
	add
	sub
	neg
	eq
	gt
	lt
	and
	or
	not



Unit 1.4

[0315]-	everything seen is imaginary!

we need to make an imaginary machine real. What to do?
	first, we need to map every segment on the RAM (and remember it)

crash course on pointer

time to get into pseudo-assembly (soda assembly)

D = *p (what does that mean?)

*p is memory location that p points at
	check value at ram0
	look at value at ram0 value address
	in hack:
	@p
	A=M
	D=M

what does p-- mean? now D=*p
	in hack:
	@p
	M=M-1
	A=M
	D=M

[0406]-	new script!
	*q = 9
	q++

[0817]-	how do we represent this in Hack?
	SP=0
	stack base address = 256

another new script!
*SP = 17
SP++

implementation:
	@17 // D=17
	D=A
	@SP // *SP=D
	A=M
	M=D
	@SP // SP++
	M=M+1

[0835]-	previous Hack code is implementation for push when i replaces 17

VM translator: receive stream of commands, spit out normal assembly
Perhaps a good intermediate step would be to spit out pseudo assembly



Unit 1.5

[1119]-	start with stack, 8 abstract memory segments

push/pop segment i is the syntax for every memory segment

...well... except for the constant memory segment

examples:
	push constant 17
	pop local 2
	pop static 5
	push argument 3
	pop this 2

implementation:
	we have an abstraction
	we have a Hack RAM
	SP (stack top)
	we see LCL
	stack starts at 256
	local starts at 1015?

notice: anything two below SP is kaput (dead)
can be recycled at will

implementation for push constant i
	@17 // D=17
	D=A
	@SP // *SP=D
	A=M
	M=D
	@SP // SP++
	M=M+1

implementation for pop local i
	@i		# load i
	D=A		# assign i to D register
	@LCL	# load LCL=1, value 1015
	D=M+D	# D = RAM[LCL]+i = RAM[1]+i = 1015+2 = 1017, turn into RAM[1017]

	@SP		# load SP
	M=M-1	# decrement SP to 257
	A=M		# goto RAM[257]
	D=M		# store RAM[257]... but we can no longer put it into where LCL is
	# This doesn't work anymore because I need 2 D registers but I only have one.

2nd implementation for pop local i
	@i		# load i
	D=A		# assign i to D register
	@LCL	# load LCL=1, value 1015
	D=M+D	# D = RAM[LCL]+i = RAM[1]+i = 1015+2 = 1017, turn into RAM[1017]
	@R13	# create temporary variable addr
	M=D		# set addr's memory value to 1017

	@SP		# load SP
	M=M-1	# decrement SP to 257
	A=M		# goto RAM[257]
	D=M		# store RAM[257]

	@R13	# goto addr
	A=M		# get RAM[1017]
	M=D		# RAM[1017]=RAM[257]
	# Note: There's no cleanup required because the new value at SP will be overwritten.

what I need to do:
first, calculate what the address at LCL + i is
then I need to decrement SP
finally I need to set wherever the address is to wherever SP is

four memory segments together:
	local, argument - local variables in function, arguments of function
	this, that - object fields, array entries
	abstractly, used the same way!
	implemented in the same way!

pseudo-assembly code for segments:
	addr = segmentPointer + i, *SP = *addr, SP++
	addr = segmentPointer + i, SP--, *addr = *SP

common question: where are the four memory segments located?
	answer: it's handled by the OS

next memory segment is constant:
	compiler often encounters constants and has to translate them into a constant segment.
	commands:
		only push constant i. there's no pop constant i operation - that wouldn't make sense.
	implementation of commands:
		push constant i: *SP = i, SP++
		@i		# i = 2 in this example
		D=A		# D = 2
		@SP		# SP = 256 in this example
		A=M		# A = 256, RAM[256] is selected
		M=D		# M = I
		@SP		# SP = 256
		M=M+1	# SP++

[1400]- Implementing static variables

Static variables should be seen by everyone

Solution: store them in a global space!
	We need a VM reference "static i" in the file Foo.vm turned into an assembly reference called Foo.i.

create variable @Foo.5 at the end and store the variable locally

static variables will be mapped to RAM[16] through RAM[255] (in case you need so many!)

there is one weird convention: there is no variable sorting so order matters!

previously, Shimon has said nothing about the underlying platform (other than the stack)
now, we are dealing with the fact that everything is based on one platform for everyone to access.

temp is a fixed 8-place memory segment going from RAM[5..12]
leaves 3 extra variables to use: R13, R14, and R15.
Base address: 5





April 14th, 2022

[Still on Unit 1.5]

[1041]
pointer is a fixed two-place segment:
	push pointer 0/1
	pop pointer 0/1

accessing pointer 0: accessing THIS
accessing pointer 1: accessing THAT

funny joke: "with THIS in mind, or with THAT in mind, as you please"

implementation for push pointer 0/1
	@THIS/THAT	# we use whatever is dictated
	D=M			# D = value of THIS/THAT
	@SP			# SP = 256 in this example
	A=M			# A = 256, RAM[256] is selected
	M=D			# M = I
	@SP			# SP = 256
	M=M+1		# SP++

Arithmetic / Logical commands
	add
	sub
	neg
	eq
	get?? where did THAT come from? (actually it's a typo for gt)
	lt
	and
	or
	not

Memory access commands
	pop segment i
	push segment i

	(now, for constant, there is no pop)

we don't need to handle branching and function commands yet



Unit 1.6

[1120]-	The VM emulator gets VM code to run on your PC, not just the Hack computer.

It's helpful for a number of reasons:
	Typical uses:
		Running compiled Jack programs
		Testing programs systematically
		Experimenting with VM commands
		Observing the VM internals like the stack and memory segments (20² lines now!)
		Observing how the VM is realized on the host platform
	
	Personal uses:
		Tinkering with the program
		Waiting for some bouncy ball on the screen (that never comes)
		Pondering Jack code
		Looking at code without comments and whitespace

The VM emulator's multi-purpose pane allows you to view:
	Program output
	Test script
	Output file
	Compare file

Test scripts take Name.vm and have NameVME.tst.

if the VM translator passes all the tests, it signals the end of your learning.
otherwise, it raises a nice red error with lines you need to fix.

I'm being so negative about passing tests because it means you can't learn more.
On the other hand, when you get an error, it's nice because you can learn more now!

There's no need to delve into the code of test scripts
	...but who cares about what you "need", gimme the learning opportunities now!

missing elements:
	sequences of instructions are VM files without the function-return envelope
	you need to take care of initializations

next: VM emulator demo!
	fast forward: single step collection

recap:
	the VM emulator helps us:
		Run and test high-level programs
		Understand the VM
			abstraction
			implementation



Unit 1.7

[1316]

CAPS-LOCK
VM translator review
	CONVENTION: Write comment for what line you are translating!

Prerequisites for VM translator:
	Understand VM
	Understand HA
	Understand mapping between VM and HA

Source: VM
	Composed of two fields: arithmetic/logical commands and memory access commands.
	Arithmetic/Logical commands:
		add
		sub
		neg
		eq
		gt
		lt
		and
		or
		not
	Memory access commands:
		pop segment i
		push segment i

	(technically VM also has branching and function commands, but that's project 8, not 7)





April 15th, 2022

[Still on Unit 1.7]

Target: HA
	C-instructions
	A-instructions
	and that is it. very simple language.

Standard VM mapping:
	VM mapping decisions:
		How to map the VM's data structures using the host hardware platform
		How to exprses the VM's commands using the host machine language

	Standard mapping:
		Specifies how to do the mapping in an agreed-upon way
		Benefits:
			Compatibility with other software systems
			Standard testing

The standard mapping gives:
	5 stack pointers
	temp segment
	3 general perpose registers
	static variables
	a giant stack



Unit 1.8

The VM translator: usage
	take myProg.vm
	run java VMTranslator myProg.vm (depends on language and machine)
	myProg.asm will be created
	use Sublime Text(?) to open myProg.asm

Proposed design:
	Parser:		parses each VM command into its lexical elements
	CodeWriter:	writes the assembly code that implements the parsed commands
	Main:		drives the process (VMTranslator)

	Main (VMTranslator)
	Input: fileName.vm
	Output: fileName.asm

	Main logic:
		Constructs a Parser to handle input file
		Constructs a CodeWriter to handle the output file
		Marches through the input file, parsing each line and generating code from it.

You need to know how to parse files before starting!
If you don't know you should probably go look it up.

The parser:
	Handles the parsing of a single .vm file,
	Reads a VM command, separates the components, and hands them to the CodeWriter conveniently, and
	Ignores all whitespace and comments (doesn't remove them, but skips over them)

I call this the HRI or PHRI (pronounced "fry") protocol!

Routine				Arguments			Returns			Function

Constructor			Input file/stream	——				Gets ready to parse input.

hasMoreCommands		——					Boolean			Are there more commands in input?

advance				——					——				Reads next command and makes it current command.
														Only called if hasMoreCommands is true.
														There is no initial current command.

arg1				——					string			Using .split(), return splitCommand[0].
														If C_ARITHMETIC is detected, return entire command.

arg2				——					int				Returns second arg of current command.
														Only called if C_PUSH, C_POP, C_FUNCTION, or C_CALL.

commandType			——					C_ARITHMETIC,	Returns constant representing type of command.
										C_PUSH, C_POP,	C_ARITHMETIC is returned for all arithmetic and
										C_LABEL,		logical commands.
										C_GOTO, C_IF,
										C_FUNCTION,
										C_RETURN,
										C_CALL


CodeWriter API generates assembly code from parsed VM command.

Routine				Arguments			Returns			Function

Constructor			Output file/stream	——				Gets ready to write output.

writeArithmetic		command (string)	——				Writes assembly code that implements C_ARITHMETIC.

writePushPop		push/pop command,	——				Writes assembly code that implements given command.
					segment (str),
					index (int)

Close				——					——				Closes output file.

More routines will be added in Project 8!

But you can add private methods to make code more manageable.

[I've worked on project 7 from around April 15 to May 03 and there were several development gaps.]

from enum import Enum
class Shake(Enum):
	VANILLA = 7
	CHOCOLATE = 4
	COOKIES = 9
	MINT = 3

for shake in Shake:
	print(shake)





May 3rd, 2022



Unit 2.1: Program Control

everything was predetermined
	start at high-level
	break down to x = -b+sqrt(disc(a,b,c))
	step back and see abstractions

functions:
	all functions are abstractions!
	what about implementation?
	the basic language can be extended  at  will

	branching: maybe check if a==0
	compiler translates code





May 4th, 2022



Branching commands:
	goto label (that's literally @LABEL, 0;JMP)
	if-goto label (check if current command is -1, jump in that case)
	label label (add (LABEL))
Function commands:
	call function
	function function
	return

Take home lessons:
	Branching
	Functions
	Function call-and-return
	Dynamic memory management
	Stack processing
	Pointers
	Completing the VM implementation

next unit: branching!



Unit 2.2: Branching

started with arithmetic, logical, memory segment commands
now working on branching commands 

branching is easy to understand
usually, we'd just go straight down in program
branching adds all sorts of curves and twisty-turns!

low-level:
	unconditional branching
	conditional branching

pseudo-vm
	mult's naive while loop uses labels!
	we don't "have" to worry about the compiler... but I want to
	if-goto requires a push operation just before the if-goto command
		pops the top of the stack!

three branching:
	goto label
	if-goto label
	label label

	implementation:
		translate each branching command into assembly instructions that effect the specified opperation
		this is simple because the assembly language has similar branching commands!



Unit 2.3: Functions

high-level programming is just a set of basic functions, plus:
	Subroutines
	Functions
	Procedures
	Methods
	And more

where do all of these come from?
	different languages have different specifications
	we call these "functions"

how do we implement the notion of FUNCTIONS?
	a high-level program with a square root and multiplication can be simplified to abstract functions
	There are two features in VM:
		primitive operations (fixed) such as add, sub, neg
		abstract operations (extensible) such as Math.multiply, Math.sqrt, etc.
		you can try writing more!

if you want to call a function:
	push all parameters to function
	call function, execute "magic"
	result will replace parameters

primitive operators and calling functions just executes a function. 

VM code for naive mult:
	function mult 2
	push constant 0
	pop local 0
	push constant 1
	pop local 1
label LOOP
	push local 1
	push argument 1
	gt
	if-goto END
	push local 0
	push argument 0
	add
	pop local 0
	push local 1
	push constant 1
	add
	pop local 1
	goto LOOP
label END
	push local 0
	return

functions:
	function functionName nArgs, where:
		functionName is the name of the function, and
		nArgs is a positive integer of arguments.

	call functionName nArgs 2
		functionName is name of the function
		nArgs is a positive integer of arguments

	calling function: caller
	called function: callee

main view:
	after line 3: stack
				  _______
				  |		|
				  |  3  |
				  |_____|
				  |		|
				  |  8  |
				  |_____|
				  |		|
				  |  5  |
				  |_____|

	
	after line 4: stack has 3 and 40

	after line 5: stack has 43

mult view:
	stack is empty			argument has 8 and 5		local has 0 and 0

	stack has 1 and 5		argument has 8 and 5		local has 0 and 1

	stack now has 40		argument has 8 and 5		local has 40 and 6


line triple 7! What to do to make this clever "magic" happen?

for each function call, the code has to:
	pass parameters from the calling function to the called function
	determine the return address within the caller's code
	save the caller's return address, stack, and memory segments
	jump to execute the called function

think about this as an adventure: you go on a loop and have to arrive at the exact next instruction

for each return, the code has to:
	return to the caller the value computed by the called function
	recycle the memory resources used by the called function
		you MUST push a value onto the stack before you return!!
	reinstate the caller's stack and memory segments
	jump to the return address in the caller's code



Unit 2.4: Function Call and Return: Implementation Preview

How to implement call, function, and return:
	2.4 = Implementation Preview 
	2.5 = Run-time simulation
	2.6 = Detailed implementation

function execution:
	A program usually has many functions
	1-2 functions are executing at the same time usually
	Calling chain: foo>bar>sqrt>...

for each function in chain, we have to maintain the state of the function

function state is also imaginary

working stack and some segments should be:
	created when the function starts runnign,
	maintained as long as the function is executing
	recycled when the function returns

how do we maintain all of these states?
	calling pattern is LIFO (last in first out, stack)
	___ (upper hand)
	 ↑
	 |
	___ (lower hand)
	 
	 |
	 ↓

	 this VM's favorite datastructure: the stack!

Example! compute 17 * 212 or mult(17, 212)

Net effect was the functions arguments replaced by function value

funny example:
	You have a robotic Robbie cleaning rugs. It cleans the rug while you watch it.
	It is running a function as it cleans the rug; that's how it functions (haha).
	Eventually, you shout: "Hey Robbie, make me a cup of tea!"
	Robbie stops what it's doing, and runs another function making a cup of tea.
	Later: Robbie finishes making tea for you. He returns the cup to you.
	Robbie is done with the tea function, now he is going back to cleaning up.

introduction: the global stack

many pairs of caller-callee up the calling chain
your stack can only handle so much of that, and will have to save states of other functions

frame only contains four memory segment values even though there are 8 others. Segments:
	Local
	Argument
	This
	That
	Static
	Constant
	Pointer
	Temp

uses the same stack for both arithmetic-logical commands and behind-the-scene work!
behind-the-scene work includes saving addresses

How to compute function(x1, x2, ...)
Abstraction: call stack with arguments ➜ the value

Implementation: went over it, details later!

"Any sufficiently advanced technology is indistinguishable from magic."
——Arthur C. Clarke (1962)
