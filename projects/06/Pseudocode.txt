â˜€ Pseudocode for the Assembler â˜€

ðŸŽ´ Figure out how the **** you read files
	Maybe look this up online, or have an experimental project.

Basic assembler translates symbol-less code
	create Parser, Code classes
	add hasMoreCommands(), advance() methods
	read and separate an instruction
		if there is an equal sign, register comp and dest. If there is
		a semicolon, register jump.
		retrieve respective binary numbers from table of values
		put string together to form output string
		if there is an @, add a 0 to the beginning of the string and
		find 15-digit number after the @. convert it to binary

Start symbol translations for symbol files
	create SymbolTable class (datastructure is dictiohnary)
	initialize builtin symbols (R0 â†’ R1, screen-keybard, others)
	add symbolExists() method
	go through all the instructions in file
	if the syntax is (x), add to collection
		Use symbol table class with a dict
		Add symbol-value pairs to the dict
	otherwise, continue to scan instructions until end of file

Combine these classes into a full assembler
	create Assembler class
	first pass:
		search labels. add to symbol table
	second pass:
		search for more variables while translating instructions. 


ðŸ•¯ Testing for the Assembler ðŸ•¯

Basic assembler test files:
	Add.asm (no AddL.asm because Add.asm has no symbols)
	MaxL.asm
	RectangleL.asm
	PongL.asm? (very long. questionable test file)

Symbol translation test files:
	Max.asm
	Rectangle.asm
	Pong.asm? (very long, questionable test)

	Note that files from the Add folder do not have symbols.

Full assembler test files:
	Add.asm (could have something wrong testing add.asm)
	Max.asm
	MaxL.asm
	Rectangle.asm
	RectangleL.asm
	Pong.asm
	PongL.asm
	Note that Pong files should be tested only here.
