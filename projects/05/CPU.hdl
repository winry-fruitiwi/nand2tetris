// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/05/CPU.hdl

/**
 * The Hack CPU (Central Processing unit), consisting of an ALU,
 * two registers named A and D, and a program counter named PC.
 * The CPU is designed to fetch and execute instructions written in 
 * the Hack machine language. In particular, functions as follows:
 * Executes the inputted instruction according to the Hack machine 
 * language specification. The D and A in the language specification
 * refer to CPU-resident registers, while M refers to the external
 * memory location addressed by A, i.e. to Memory[A]. The inM input 
 * holds the value of this location. If the current instruction needs 
 * to write a value to M, the value is placed in outM, the address 
 * of the target location is placed in the addressM output, and the 
 * writeM control bit is asserted. (When writeM==0, any value may 
 * appear in outM). The outM and writeM outputs are combinational: 
 * they are affected instantaneously by the execution of the current 
 * instruction. The addressM and pc outputs are clocked: although they 
 * are affected by the execution of the current instruction, they commit 
 * to their new values only in the next time step. If reset==1 then the 
 * CPU jumps to address 0 (i.e. pc is set to 0 in next time step) rather 
 * than to the address resulting from executing the current instruction. 
 */

CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset==1) or continue executing
                         // the current program (reset==0).

    OUT outM[16],        // M value output
        writeM,          // Write to M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    PARTS:
    // Put your code here:
        /* find the load bit for the ARegister TODO: unnecessary code */
        // this code turns out to be unecessary because it always turns into 1.
        // And (a=instruction[5], b=instruction[15], out=aIfAIsOne);
        // Not (in=aIfAIsOne, out=aBeforeMux);
        Mux (a=true, b=instruction[5], sel=instruction[15], out=registerALoadBit);
        

        /* find the value we need to pass into the ARegister */
        Mux16 (a=instruction, b=ALUOutput, sel=instruction[15], out=ARegisterValue);

        
        /* pass the load bit and the value into the ARegister chip */
        ARegister (in=ARegisterValue, load=registerALoadBit, out=Aregout, out[0..14]=addressM);

        
        /* find the load bit for the DRegister */
        And (a=instruction[4], b=instruction[15], out=DRegisterLoadBit);
        
        
        /* pass in the ALU's output and the load bit for the D register */
        DRegister (in=ALUOutput, load=DRegisterLoadBit, out=DRegout);

        
        /* find the y input for the ALU */
        Mux16 (b=inM, a=Aregout, sel=instruction[12], out=y);

        
        /* find the control bits for the ALU  TODO: unnecessary code. replace with instruction[n] */
        // when there's an A instruction, 100010 preserves the DRegister's output because the zy and f bits are on: zy makes the y-input zero and the function is now addition instead of the logical and.
        // this is unecessary code because it doesn't matter what the ALU outputs on this frame.
        // Mux16 (a[0..5]=instruction[6..11], b[0]=true, b[1]=false, b[2]=false, b[3]=false, b[4]=true, b[5]=false, sel=instruction[15], out[5]=c1, out[4]=c2, out[3]=c3, out[2]=c4, out[1]=c5, out[0]=c6);
        
        
        /* the ALU! */
        // this is old, outdated code:
        // we could feed the bits directly into the ALU, but using the mux makes the code shorter and easier to read.
        // ALU (x=DRegout, y=y, zx=c1, nx=c2, zy=c3, ny=c4, f=c5, no=c6, out=ALUOutput, ng=ifneg, zr=ifzero, out=outM);
        // this is newer code that's less messy
        ALU (x=DRegout, y=y, zx=instruction[11], nx=instruction[10], zy=instruction[9], ny=instruction[8], f=instruction[7], no=instruction[6], out=ALUOutput, ng=ifneg, zr=ifzero, out=outM);
        
        
        /* compute the different jump bits. The first three lines find JGE and JGT. The next two lines find JNE and JLE. Note that some of the jump bits are left out in these calculations, since they don't require gates. */
        Not (in=ifneg, out=JGE);
        Not (in=ifzero, out=notzero);
        And (a=JGE, b=notzero, out=JGT);
        Not (in=ifzero, out=JNE);
        Or (a=ifneg, b=ifzero, out=JLE);

        
        /* use a mux to decide which jump condition we need. this is the PC load bit. */
        // I don't know which one of these are right.
        Mux8Way16 (a[0]=false, b[0]=JGT, c[0]=ifzero, d[0]=JGE, e[0]=ifneg, f[0]=JNE, g[0]=JLE, h[0]=true, sel=instruction[0..2], out[0]=PCLoad);
        // Mux8Way16 (g[0]=false, f[0]=JGT, e[0]=ifzero, d[0]=JGE, c[0]=ifneg, b[0]=JLE, a[0]=true, sel=instruction[3..5], out[0]=PCLoad);
        And (a=instruction[15], b=PCLoad, out=PCLoadIfNotAInstruction);
        
        /* the PC. currently I'm passing in false for load. that is a placeholder value. */
        PC (in=Aregout, reset=reset, load=PCLoadIfNotAInstruction, inc=true, out[0..14]=pc);

        
        /* calculate whether or not we wrote to the current memory register. */
        And (a=instruction[3], b=instruction[15], out=writeM);
}